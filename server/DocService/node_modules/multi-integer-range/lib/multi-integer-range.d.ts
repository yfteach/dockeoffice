/*! multi-integer-range (c) 2015 Soichiro Miki */
export declare type Range = [number, number];
export declare type Initializer = string | number | (number | Range)[] | MultiRange;
export declare type Options = {
    parseNegative?: boolean;
    parseUnbounded?: boolean;
};
export declare class MultiRange {
    private ranges;
    private options;
    /**
     * Creates a new MultiRange object.
     */
    constructor(data?: Initializer, options?: Options);
    /**
     * Parses the initializer string and build the range data.
     * Override this if you need to customize the parsing strategy.
     */
    protected parseString(data: string): void;
    /**
     * Clones this instance.
     * @returns The cloned instance.
     */
    clone(): MultiRange;
    /**
     * Appends to this instance.
     * @param value The data to append.
     */
    append(value: Initializer): MultiRange;
    /**
     * Appends a specified range of integers to this isntance.
     * @param min The minimum value of the range to append.
     * @param max The maximum value of the range to append.
     */
    private appendRange;
    /**
     * Subtracts from this instance.
     * @param value The data to subtract.
     */
    subtract(value: Initializer): MultiRange;
    /**
     * Subtracts a specified range of integers from this instance.
     * @param min The minimum value of the range to subtract.
     * @param max The maximum value of the range to subtract.
     */
    private subtractRange;
    /**
     * Remove integers which are not included in `value`,
     * yielding the intersection of this and `value`.
     * @param value The data to calculate the intersetion.
     */
    intersect(value: Initializer): MultiRange;
    /**
     * Determines how the given range overlaps or touches the existing ranges.
     * This is a helper method that calculates how an append/subtract operation
     * affects the existing range members.
     * @param target The range array to test.
     * @returns An object containing information about how the given range
     * overlaps or touches this instance.
     */
    private findOverlap;
    /**
     * Calculates the union of two specified ranges.
     * @param a Range A.
     * @param b Range B.
     * @returns Union of `a` and `b`.
     *   Returns `null` if `a` and `b` do not touch nor intersect.
     */
    private calcUnion;
    /**
     * Exports the whole range data as an array of arrays.
     * @returns An copied array of range segments.
     */
    getRanges(): Range[];
    /**
     * Checks if this instance contains the specified value.
     * @param value Value to be checked.
     * @returns True if the specified value is included in the instance.
     */
    has(value: Initializer): boolean;
    /**
     * Checks if this instance contains the range specified by the two parameters.
     * @param min The minimum value of the range to subtract.
     * @param max The minimum value of the range to subtract.
     * @returns True if the specified value is included in the instance.
     */
    private hasRange;
    /**
     * Returns the number of range segments.
     * For example, the segmentLength of `2-5,7,9-11` is 3.
     * @returns The number of segments. Returns 0 for an empty instance.
     */
    segmentLength(): number;
    /**
     * Calculates how many numbers are effectively included in this instance.
     * For example, the length of `1-10,51-60,90` is 21.
     * @returns The number of integer values in this instance.
     *    Returns `Infinity` for an unbounded range.
     */
    length(): number;
    /**
     * Checks if two instances of MultiRange are identical.
     * @param cmp The data to compare.
     * @returns True if `cmp` is exactly the same as this instance.
     */
    equals(cmp: Initializer): boolean;
    /**
     * Checks if the current instance is unbounded (i.e., infinite).
     */
    isUnbounded(): boolean;
    /**
     * Returns the minimum integer contained in this insntance.
     * Can be -Infinity or undefined.
     * @returns The minimum integer of this instance.
     */
    min(): number | undefined;
    /**
     * Returns the maximum number contained in this insntance.
     * Can be Infinity or undefined.
     * @returns The maximum integer of this instance.
     */
    max(): number | undefined;
    /**
     * Removes the smallest integer from this instance and returns it.
     * @returns The minimum integer removed from this instance.
     */
    shift(): number | undefined;
    /**
     * Removes the largest integer from this instance and returns it.
     * @returns The maximum integer removed from this instance.
     */
    pop(): number | undefined;
    /**
     * Returns the string respresentation of this MultiRange.
     */
    toString(): string;
    /**
     * Builds a flat array of integers which holds all elements in this instance.
     * Note that this may be slow and memory-consuming for large ranges.
     * Consider using the iterator whenever possible.
     */
    toArray(): number[];
    /**
     * Returns an ES6-compatible iterator.
     */
    getIterator(): {
        next: () => {
            done?: boolean;
            value?: number;
        };
    };
}
export default MultiRange;
/**
 * A shorthand function to construct a new MultiRange instance.
 * @returns The new MultiRnage instance.
 */
export declare function multirange(data?: Initializer, options?: Options): MultiRange;
